import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

/// Interaction extensions
extension InteractionExtensions on Widget {
  /// A widget that absorbs pointers during hit testing.
  ///
  /// If you want to make widgets behind this widget receive pointer events,
  /// use [IgnorePointer] instead.
  Widget absorbPointer({
    Key? key,
    bool absorbing = true,
    bool? ignoringSemantics,
  }) {
    return AbsorbPointer(
      key: key,
      absorbing: absorbing,
      ignoringSemantics: ignoringSemantics,
      child: this,
    );
  }

  /// A widget that can be dismissed by dragging in the indicated direction.
  Widget dismissable({
    required Key key,
    Widget? background,
    Widget? secondaryBackground,
    ConfirmDismissCallback? confirmDismiss,
    VoidCallback? onResize,
    DismissUpdateCallback? onUpdate,
    DismissDirectionCallback? onDismissed,
    DismissDirection direction = DismissDirection.horizontal,
    Duration? resizeDuration = const Duration(milliseconds: 300),
    Map<DismissDirection, double> dismissThresholds =
        const <DismissDirection, double>{},
    Duration movementDuration = const Duration(milliseconds: 200),
    double crossAxisEndOffset = 0.0,
    DragStartBehavior dragStartBehavior = DragStartBehavior.start,
    HitTestBehavior behavior = HitTestBehavior.opaque,
  }) {
    return Dismissible(
      key: key,
      background: background,
      secondaryBackground: secondaryBackground,
      confirmDismiss: confirmDismiss,
      onResize: onResize,
      onUpdate: onUpdate,
      onDismissed: onDismissed,
      direction: direction,
      resizeDuration: resizeDuration,
      dismissThresholds: dismissThresholds,
      movementDuration: movementDuration,
      crossAxisEndOffset: crossAxisEndOffset,
      dragStartBehavior: dragStartBehavior,
      behavior: behavior,
      child: this,
    );
  }

  /// A widget that can be dragged from to a [DragTarget].
  Widget draggable<T extends Object>({
    required Widget feedback,
    Key? key,
    T? data,
    Axis? axis,
    Widget? childWhenDragging,
    Offset feedbackOffset = Offset.zero,
    DragAnchorStrategy dragAnchorStrategy = childDragAnchorStrategy,
    Axis? affinity,
    int? maxSimultaneousDrags,
    VoidCallback? onDragStarted,
    DragUpdateCallback? onDragUpdate,
    DraggableCanceledCallback? onDraggableCanceled,
    DragEndCallback? onDragEnd,
    VoidCallback? onDragCompleted,
    bool ignoringFeedbackSemantics = true,
    bool ignoringFeedbackPointer = true,
    bool rootOverlay = false,
    HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild,
    AllowedButtonsFilter? allowedButtonsFilter,
  }) {
    return Draggable<T>(
      key: key,
      feedback: feedback,
      data: data,
      axis: axis,
      childWhenDragging: childWhenDragging,
      feedbackOffset: feedbackOffset,
      dragAnchorStrategy: dragAnchorStrategy,
      affinity: affinity,
      maxSimultaneousDrags: maxSimultaneousDrags,
      onDragStarted: onDragStarted,
      onDragUpdate: onDragUpdate,
      onDraggableCanceled: onDraggableCanceled,
      onDragEnd: onDragEnd,
      onDragCompleted: onDragCompleted,
      ignoringFeedbackSemantics: ignoringFeedbackSemantics,
      ignoringFeedbackPointer: ignoringFeedbackPointer,
      rootOverlay: rootOverlay,
      hitTestBehavior: hitTestBehavior,
      allowedButtonsFilter: allowedButtonsFilter,
      child: this,
    );
  }

  /// Wraps this widget in a [GestureDetector].
  Widget gestures({
    Key? key,
    GestureTapDownCallback? onTapDown,
    GestureTapUpCallback? onTapUp,
    GestureTapCallback? onTap,
    GestureTapCancelCallback? onTapCancel,
    GestureTapCallback? onSecondaryTap,
    GestureTapDownCallback? onSecondaryTapDown,
    GestureTapUpCallback? onSecondaryTapUp,
    GestureTapCancelCallback? onSecondaryTapCancel,
    GestureTapDownCallback? onTertiaryTapDown,
    GestureTapUpCallback? onTertiaryTapUp,
    GestureTapCancelCallback? onTertiaryTapCancel,
    GestureTapDownCallback? onDoubleTapDown,
    GestureTapCallback? onDoubleTap,
    GestureTapCancelCallback? onDoubleTapCancel,
    GestureLongPressDownCallback? onLongPressDown,
    GestureLongPressCancelCallback? onLongPressCancel,
    GestureLongPressCallback? onLongPress,
    GestureLongPressStartCallback? onLongPressStart,
    GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate,
    GestureLongPressUpCallback? onLongPressUp,
    GestureLongPressEndCallback? onLongPressEnd,
    GestureLongPressDownCallback? onSecondaryLongPressDown,
    GestureLongPressCancelCallback? onSecondaryLongPressCancel,
    GestureLongPressCallback? onSecondaryLongPress,
    GestureLongPressStartCallback? onSecondaryLongPressStart,
    GestureLongPressMoveUpdateCallback? onSecondaryLongPressMoveUpdate,
    GestureLongPressUpCallback? onSecondaryLongPressUp,
    GestureLongPressEndCallback? onSecondaryLongPressEnd,
    GestureLongPressDownCallback? onTertiaryLongPressDown,
    GestureLongPressCancelCallback? onTertiaryLongPressCancel,
    GestureLongPressCallback? onTertiaryLongPress,
    GestureLongPressStartCallback? onTertiaryLongPressStart,
    GestureLongPressMoveUpdateCallback? onTertiaryLongPressMoveUpdate,
    GestureLongPressUpCallback? onTertiaryLongPressUp,
    GestureLongPressEndCallback? onTertiaryLongPressEnd,
    GestureDragDownCallback? onVerticalDragDown,
    GestureDragStartCallback? onVerticalDragStart,
    GestureDragUpdateCallback? onVerticalDragUpdate,
    GestureDragEndCallback? onVerticalDragEnd,
    GestureDragCancelCallback? onVerticalDragCancel,
    GestureDragDownCallback? onHorizontalDragDown,
    GestureDragStartCallback? onHorizontalDragStart,
    GestureDragUpdateCallback? onHorizontalDragUpdate,
    GestureDragEndCallback? onHorizontalDragEnd,
    GestureDragCancelCallback? onHorizontalDragCancel,
    GestureForcePressStartCallback? onForcePressStart,
    GestureForcePressPeakCallback? onForcePressPeak,
    GestureForcePressUpdateCallback? onForcePressUpdate,
    GestureForcePressEndCallback? onForcePressEnd,
    GestureDragDownCallback? onPanDown,
    GestureDragStartCallback? onPanStart,
    GestureDragUpdateCallback? onPanUpdate,
    GestureDragEndCallback? onPanEnd,
    GestureDragCancelCallback? onPanCancel,
    GestureScaleStartCallback? onScaleStart,
    GestureScaleUpdateCallback? onScaleUpdate,
    GestureScaleEndCallback? onScaleEnd,
    HitTestBehavior? behavior,
    bool excludeFromSemantics = false,
    DragStartBehavior dragStartBehavior = DragStartBehavior.start,
    bool trackpadScrollCausesScale = false,
    Offset trackpadScrollToScaleFactor = kDefaultTrackpadScrollToScaleFactor,
    Set<PointerDeviceKind>? supportedDevices,
  }) {
    return GestureDetector(
      key: key,
      onTapDown: onTapDown,
      onTapUp: onTapUp,
      onTap: onTap,
      onTapCancel: onTapCancel,
      onSecondaryTap: onSecondaryTap,
      onSecondaryTapDown: onSecondaryTapDown,
      onSecondaryTapUp: onSecondaryTapUp,
      onSecondaryTapCancel: onSecondaryTapCancel,
      onTertiaryTapDown: onTertiaryTapDown,
      onTertiaryTapUp: onTertiaryTapUp,
      onTertiaryTapCancel: onTertiaryTapCancel,
      onDoubleTapDown: onDoubleTapDown,
      onDoubleTap: onDoubleTap,
      onDoubleTapCancel: onDoubleTapCancel,
      onLongPressDown: onLongPressDown,
      onLongPressCancel: onLongPressCancel,
      onLongPress: onLongPress,
      onLongPressStart: onLongPressStart,
      onLongPressMoveUpdate: onLongPressMoveUpdate,
      onLongPressUp: onLongPressUp,
      onLongPressEnd: onLongPressEnd,
      onSecondaryLongPressDown: onSecondaryLongPressDown,
      onSecondaryLongPressCancel: onSecondaryLongPressCancel,
      onSecondaryLongPress: onSecondaryLongPress,
      onSecondaryLongPressStart: onSecondaryLongPressStart,
      onSecondaryLongPressMoveUpdate: onSecondaryLongPressMoveUpdate,
      onSecondaryLongPressUp: onSecondaryLongPressUp,
      onSecondaryLongPressEnd: onSecondaryLongPressEnd,
      onTertiaryLongPressDown: onTertiaryLongPressDown,
      onTertiaryLongPressCancel: onTertiaryLongPressCancel,
      onTertiaryLongPress: onTertiaryLongPress,
      onTertiaryLongPressStart: onTertiaryLongPressStart,
      onTertiaryLongPressMoveUpdate: onTertiaryLongPressMoveUpdate,
      onTertiaryLongPressUp: onTertiaryLongPressUp,
      onTertiaryLongPressEnd: onTertiaryLongPressEnd,
      onVerticalDragDown: onVerticalDragDown,
      onVerticalDragStart: onVerticalDragStart,
      onVerticalDragUpdate: onVerticalDragUpdate,
      onVerticalDragEnd: onVerticalDragEnd,
      onVerticalDragCancel: onVerticalDragCancel,
      onHorizontalDragDown: onHorizontalDragDown,
      onHorizontalDragStart: onHorizontalDragStart,
      onHorizontalDragUpdate: onHorizontalDragUpdate,
      onHorizontalDragEnd: onHorizontalDragEnd,
      onHorizontalDragCancel: onHorizontalDragCancel,
      onForcePressStart: onForcePressStart,
      onForcePressPeak: onForcePressPeak,
      onForcePressUpdate: onForcePressUpdate,
      onForcePressEnd: onForcePressEnd,
      onPanDown: onPanDown,
      onPanStart: onPanStart,
      onPanUpdate: onPanUpdate,
      onPanEnd: onPanEnd,
      onPanCancel: onPanCancel,
      onScaleStart: onScaleStart,
      onScaleUpdate: onScaleUpdate,
      onScaleEnd: onScaleEnd,
      behavior: behavior,
      excludeFromSemantics: excludeFromSemantics,
      dragStartBehavior: dragStartBehavior,
      trackpadScrollCausesScale: trackpadScrollCausesScale,
      trackpadScrollToScaleFactor: trackpadScrollToScaleFactor,
      supportedDevices: supportedDevices,
      child: this,
    );
  }

  /// Makes this widget completely ignore interaction events.
  /// Widgets behind it can still receive events.
  Widget ignorePointer({
    Key? key,
    bool ignoring = true,
    bool ignoringSemantics = true,
    Widget? child,
  }) {
    return IgnorePointer(
      key: key,
      ignoring: ignoring,
      ignoringSemantics: ignoringSemantics,
      child: child ?? this,
    );
  }

  /// A widget that enables pan and zoom interactions with its child.
  Widget interactiveViewer({
    Key? key,
    Clip clipBehavior = Clip.hardEdge,
    @Deprecated('Use panAxis instead. '
        'This feature was deprecated after v3.3.0-0.5.pre.')
    bool alignPanAxis = false,
    PanAxis panAxis = PanAxis.free,
    EdgeInsets boundaryMargin = EdgeInsets.zero,
    bool constrained = true,
    double maxScale = 2.5,
    double minScale = 0.8,
    double interactionEndFrictionCoefficient = 0.0000135,
    GestureScaleEndCallback? onInteractionEnd,
    GestureScaleStartCallback? onInteractionStart,
    GestureScaleUpdateCallback? onInteractionUpdate,
    bool panEnabled = true,
    bool scaleEnabled = true,
    double scaleFactor = kDefaultMouseScrollToScaleFactor,
    TransformationController? transformationController,
    Alignment? alignment,
    bool trackpadScrollCausesScale = false,
  }) {
    return InteractiveViewer(
      key: key,
      clipBehavior: clipBehavior,
      // ignore: deprecated_member_use
      alignPanAxis: alignPanAxis,
      panAxis: panAxis,
      boundaryMargin: boundaryMargin,
      constrained: constrained,
      maxScale: maxScale,
      minScale: minScale,
      interactionEndFrictionCoefficient: interactionEndFrictionCoefficient,
      onInteractionEnd: onInteractionEnd,
      onInteractionStart: onInteractionStart,
      onInteractionUpdate: onInteractionUpdate,
      panEnabled: panEnabled,
      scaleEnabled: scaleEnabled,
      scaleFactor: scaleFactor,
      transformationController: transformationController,
      alignment: alignment,
      trackpadScrollCausesScale: trackpadScrollCausesScale,
      child: this,
    );
  }

  /// Makes its child draggable starting from long press.
  Widget longPressDraggable<T extends Object>({
    required Widget feedback,
    Key? key,
    T? data,
    Axis? axis,
    Widget? childWhenDragging,
    Offset feedbackOffset = Offset.zero,
    DragAnchorStrategy dragAnchorStrategy = childDragAnchorStrategy,
    int? maxSimultaneousDrags,
    VoidCallback? onDragStarted,
    DragUpdateCallback? onDragUpdate,
    DraggableCanceledCallback? onDraggableCanceled,
    DragEndCallback? onDragEnd,
    VoidCallback? onDragCompleted,
    bool hapticFeedbackOnStart = true,
    bool ignoringFeedbackSemantics = true,
    bool ignoringFeedbackPointer = true,
    Duration delay = kLongPressTimeout,
    AllowedButtonsFilter? allowedButtonsFilter,
  }) {
    return LongPressDraggable<T>(
      key: key,
      feedback: feedback,
      data: data,
      axis: axis,
      childWhenDragging: childWhenDragging,
      feedbackOffset: feedbackOffset,
      dragAnchorStrategy: dragAnchorStrategy,
      maxSimultaneousDrags: maxSimultaneousDrags,
      onDragStarted: onDragStarted,
      onDragUpdate: onDragUpdate,
      onDraggableCanceled: onDraggableCanceled,
      onDragEnd: onDragEnd,
      onDragCompleted: onDragCompleted,
      hapticFeedbackOnStart: hapticFeedbackOnStart,
      ignoringFeedbackSemantics: ignoringFeedbackSemantics,
      ignoringFeedbackPointer: ignoringFeedbackPointer,
      delay: delay,
      allowedButtonsFilter: allowedButtonsFilter,
      child: this,
    );
  }
}
